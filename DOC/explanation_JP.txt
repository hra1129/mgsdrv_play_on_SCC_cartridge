【解説】
	MGSDRVは、自分自身を書き替えるコードを含むため RAM上でしか動作しません。
	また、6000h-7FFFh に配置されることが前提となります。

	先頭の 15byte と、最後の方に MSX-DOSのコマンドとして利用するためのコード領域が
	含まれていて、ROMカートリッジ上で利用する場合は不要な部分ですが、MGSDRV の
	ライセンスとして、"組み込んで利用する場合は MGSDRV.COM をそのまま利用すること"
	が条件となっていますので、その不要な部分も含めて ROM に書き込みます。

	---------------------------------------------------------------------------
	entry::
			di
			; Initialize Stack Pointer
			ld			hl, [himem]
			ld			de, ramad0
			or			a, a
			sbc			hl, de
			ld			sp, ramad0
			jp			nc, skip1
			ld			sp, [himem]
	skip1:
	---------------------------------------------------------------------------

	この部分はスタックポインタの初期化です。

	---------------------------------------------------------------------------
			call		init_memory_mapper
	---------------------------------------------------------------------------

	MSX1 に MemoryMapper対応RAM を増設している場合、MemoryMapperが初期化されておらず、
	1つの MapperSegment が複数の Page に出現していることがあり、後の RAM探索に不都合
	が出るため、MemoryMapper を初期化します。

	---------------------------------------------------------------------------
			call		get_rom_slot
	---------------------------------------------------------------------------

	現在実行中のプログラムコードは、ROM上で実行されていて 4010hから起動してるので
	Page1 の SLOT は ROMカートリッジを指していることが明らかです。
	これを利用して、自身の ROMカートリッジのスロット番号を取得する処理です。
	RAMスロットに切り替えた後、ROMスロットに戻せるようにするための準備です。

	---------------------------------------------------------------------------
			call		search_page1_dram_slot
	---------------------------------------------------------------------------

	Page1 の RAMスロットを探索するルーチンを呼びます。
	すべての SLOT を探索して、Page1 に RAMが存在しない場合は、エラーメッセージを
	表示して停止します。

	---------------------------------------------------------------------------
			call		search_page2_dram_slot
	---------------------------------------------------------------------------

	Page2 の RAMスロットを探索するルーチンを呼びます。

	---------------------------------------------------------------------------
			jp			transfer_to_ram
	---------------------------------------------------------------------------

	Page1 を RAM に切り替えます。
	ROM の Bank3 (A000h-BFFFh) に MGSDRVが入っている Bank# を選択して、
	RAM の 6000h-7FFFh へコピーします。
	Bank3 を MAIN_PROGRAMが入っている Bank# に切り替え、
	RAM の 4000h-5FFFh へコピーします。
	"初期化ルーチンの一部" と、H.TIMI処理ルーチン(mgsdrv_h_timi) を Page3 にコピーします。
	H.TIMI の内容を Page3 にコピーします。
	コピーした"初期化ルーチンの一部" へジャンプ。

	Bank2 を SCCレジスターのBank# 3Fh へ切り替えます。
	Page2 を RAM に切り替えます。Page1 を ROM に切り替えます。
	Bank0と1 を TEST.MGS のBank#へ切り替えます。
	TEST.MGS を Page1 の ROM から Page2 の RAM へコピーします。
	Page1 も RAM に切り替えます。
	Page1 の RAM上にあるコード(MAIN_PROGRAM)へジャンプします。

	MGSDRV の H.TIMI で呼ばれることを期待している「割り込み処理ルーチン」は、
	SCCカートリッジの Bank2 を SCCレジスターの Bank# に切り替える処理を実施しません。
	これは、MGSDRV を初期化したときに1回だけ行うことによって、毎回バンク切り替えする
	手間を省いているわけです。

	MGSDRV は、曲データを 8000h〜 に置くことを前提としています。
	そして、SCCレジスターの Bank#3Fh は Bank2 に存在します。8000h〜 です。
	MGSデータを ROMのまま再生しようとすると、MGSデータと、SCCレジスタの Bank# が
	同じで無ければなり立ちませんが、SCCレジスタの Bank# は SCCレジスタしかおらず
	MGSデータを書き込むことは出来ません。
	MGSDRV内で、割り込み処理中に Bank# を切り替えてくれれば良いのですが、そのような
	処理は入っていません。割り込み処理中だけでも Bank2 は 3Fh になっている必要
	があります。

	これを回避するために、MGSデータの方が、別のスロットの RAM上にあればなり立つ
	ので、わざわざコピーしています。

-------------------------------------------------------------------------------
【応用】
	ここから先は応用編です。

	Bank2 の Bank# を切り替えるとき、自身が作られたワーク領域に Bank# を書き込んで
	おきます。
	Page2 には、RAMを出現させておきます。
	H.TIMI処理ルーチンは、まず Page2 の Bank2 の Bank# を 3Fh に変更します。
	次に Page2 Slot# を MGSデータを書き込んだ RAMスロットに切り替えます。
	MGSDRV の割り込み処理ルーチンを呼んで戻ってきたら、
	Page2 を ROMカートリッジのスロットに戻します。
	Bank2 を 自身が作られたワーク領域に保存してある Bank# をセットします。
	古い HOOK を呼んだらおしまい。

	この方法なら、Page2 に ROM が出現するので、ROM の Bank# を切り替えながら
	大容量にも対応できるようになります。

April/22th/2021  HRA!
